<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>排序和搜索算法</title>
</head>
<body>




<script>
/**
 * 
 * 
 *
*/

const Compare = {
    'LESS_THAN': 'LESS_THAN',
    'BIGGER_THAN': 'BIGGER_THAN'
}

function swap(array, a, b) {
    const temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}

function defaultCompare(a, b) {
    return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
}

// 冒泡排序：比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素向上移动至正确的位置，就像气泡上升一样。
// 冒泡的算法复杂度是 O(n²)，是性能最差的算法

function bubbleSort(array, compareFn = defaultCompare) {
    const {length} = array;
    for(let i=0; i<length; i++) {
        for(let j=0; j<length-1; j++) {
            if(compareFn(array[j], array[j+1]) === Compare.BIGGER_THAN) {
                swap(array, j, j+1);
            }
        }
    }

    return array;
}

function modifiedBubbleSort(array, compareFn = defaultCompare) {
    const {length} = array;
    for(let i=0; i<length; i++) {
        for(let j=0; j<length - 1 - i; j++) {
            if(compareFn(array[j], array[j+1]) === Compare.BIGGER_THAN) {
                swap(array, j, j+1);
            }
        }
    }

    return array;
}


// 选择排序：找到数据结构中最小的值并将其放在第一位，接着找到第二小的值并将其放在第二位。
// 选择的算法复杂度是 O(n²)

function selectionSort(array, compareFn = defaultCompare) {
    const {length} = array;
    let indexMin;
    for(let i=0; i<length - 1; i++) {
        indexMin = i;
        for(let j=i; j < length; j++) {
            if(compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) {
                indexMin = j;
            }
        }
        if(i !== indexMin) {
            swap(array, i, indexMin);
        }
    }
    return array;
}


// 插入排序：每次排一个数组项，以此构建最后的排序数组。

function insertionSort(array, compareFn = defaultCompare) {
    const {length} = array;
    let temp;
    for(let i=0; i<length; i++) {
        let j=i;
        temp = array[i];
        while(
            j > 0 &&
            compareFn(array[j-1], temp) === Compare.BIGGER_THAN
        ) {
            array[j] = array[j-1];
            j--;
        }
    }
}


// 归并排序：是一种分而治之的算法。其思想是将原始数组切割成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的
// 数组，直到最后只有一个排序完毕的大数组。
// 归并排序的复杂度为 O(nlog(n))

function mergeSort(array, compareFn = defaultCompare) {
    if(array.length > 1) {
        const {length} = array;
        const middle = Math.floor(length / 2);
        const left = mergeSort(array.slice(0, middle), compareFn);
        const right = mergeSort(array.slice(middle, length), compareFn);
        array = merge(left, right, compareFn);
    }
    return array;
}


function merge(left, right, compareFn) {
    let i=0;
    let j=0;
    const result = [];
    while(
        i < left.length &&
        j < right.length
    ) {
        result.push(
            compareFn(left[i], right[i]) === Compare.LESS_THAN ? left[i++] : right[j++]
        );
    }
}


// 快速排序：也是分而治之的方法
// 快速排序的复杂度为 O(nlog(n))

function quickSort(array, compareFn = defaultCompare) {
    return quick(array, 0, array.length - 1, compareFn);
}

function quick(array, left, right, compareFn) {
    let index;
    if(array.length > 1) {
        index = partition(array, left, right, compareFn);
        if(left < index-1) {
            quick(array, left, index-1, compareFn);
        }
        if(index < right) {
            quick(array, index, right, compareFn);
        }
    }
    return array;
}


// 计数排序：使用一个用来存储每个元素在原始数组中出现次数的临时数组，在所有元素都计数完成后，临时数组已排好序并可以迭代
// 构建排序后的数组。时间复杂度为 O(n+k)

function countingSort(array) {
    if(array.length < 2) {
        return array;
    }
    const maxValue = findMaxValue(array);
    const counts = new Array(maxValue + 1);

    array.forEach(element => {
        if(!counts[element]) {
            counts[element] = 0;
        }
        counts[element]++;
    })

    let sortedIndex = 0;
    counts.forEach((count, i) => {
        while(count > 0) {
            array[sortedIndex++] = i;
            count--;
        }
    })

    return array;
}

function findMaxValue(array) {
    let max = array[0];
    for(let i=1; i<array.length; i++) {
        if(array[i] > max) {
            max = array[i];
        }
    }
    return max;
}

// 桶排序：也是分布式算法，它将元素分为不同的桶，再使用一个简单的排序算法，例如插入排序，对每个桶进行排序。然后合并结果。

function bucketSort(array, bucketSize = 5) {
    if(array.length < 2) {
        return array;
    }
    const buckets = createBuckets(array, bucketSize);
    return sortBuckets(buckets);
}

function createBuckets(array, bucketSize) {
    let minValue = array[0];
    let maxValue = array[0];
    for(let i=1; i<array.length; i++) {
        if(array[i] < minValue) {
            minValue = array[i];
        } else if(array[i] > maxValue) {
            maxValue = array[i];
        }
    }

    const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
    const buckets = [];
    for(let i=0; i < bucketCount; i++) {
        buckets[i] = [];
    }
    for(let i=0; i<array.length; i++) {
        const bucketIndex = Math.floor((array[i] - minValue) / bucketSize);
        buckets[bucketIndex].push(array[i]);
    }
    return buckets;
}

function sortBuckets(buckets) {
    const sortedArray = [];
    for(let i=0; i<buckets.length; i++) {
        if(buckets[i] != null) {
            insertionSort(buckets[i]);
            sortedArray.push(...buckets);
        }
    }
    return sortedArray;
}

// 基数排序：根据数字的有效位数或基数将整数分布到桶中

function radixSort(array, radixBase = 0) {
    if(array.length < 2) {
        return array;
    }
    const minValue = findMinValue(array);
    const maxValue = findMaxValue(array);

    let singnificantDigit = 1;
    while((maxValue - minValue) / singnificantDigit >= 1) {
        array = coutingSrotForRadix(array, radixBase, singnificantDigit, minValue);
        singnificantDigit *= radixBase;
    }
    return array;
}

function coutingSrotForRadix(array, radixBase, singnificantDigit, minValue) {
    let bucketsIndex;
    const buckets = [];
    const aux = [];
    for(let i=0; i<radixBase; i++) {
        buckets[i] = 0;
    }
    for(let i=0; i<array.length; i++) {
        bucketsIndex = Math.floor(((array[i] - minValue) / singnificantDigit) % radixBase);
        buckets[bucketsIndex]++;
    }
    for(let i=1; i<radixBase; i++) {
        buckets[i] += buckets[i -1];
    }
    for(let i=array.length-1; i>=0; i--) {
        bucketsIndex = Math.floor(((array[i] - minValue) / singnificantDigit) % radixBase);
        aux[--buckets[bucketsIndex]] = array[i];
    }
    for(let i=0; i<array.length; i++) {
        array[i] = aux[i];
    }
    return array;
}




</script>
</body>
</html>