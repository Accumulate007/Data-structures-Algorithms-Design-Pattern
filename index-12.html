<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>搜索算法</title>
</head>
<body>




<script>
/**
 * 
 * 
 *
*/

const Compare = {
    'LESS_THAN': 'LESS_THAN',
    'BIGGER_THAN': 'BIGGER_THAN',
    'EQUALS': 'EQUALS'
}

function lesserOrEquals(a, b, compareFn) {
    const comp = compareFn(a, b);
    return comp === Compare.LESS_THAN || comp === Compare.EQUALS;
}

function biggerOrEquals(a, b, compareFn) {
    const comp = compareFn(a, b);
    return comp = Compare.BIGGER_THAN || comp === Compare.EQUALS;
}



// 顺序搜索：将每一个数据结构中的元素与我们要找的元素做比较

const DOES_NOT_EXIST = -1;

function sequentialSearch(array, value, equalFn = defaultEquals) {
    for(let i=0; i<array.length; i++) {
        if(equalFn(value, array[i])) {
            return i;
        }
    }
    return DOES_NOT_EXIST;
}


// 二分搜索：该搜索要求被搜索的数据结构已排序

function binarySearch(array, value, compareFn = defaultCompare) {
    const sortedArray = quickSort(array);
    let low = 0;
    let high = sortedArray.length - 1;
    while(lesserOrEquals(low, high, compareFn)) {
        const mid = Math.floor((low + high) / 2);
        const element = sortedArray[mid];
        if(compareFn(element, value) === Compare.LESS_THAN) {
            low = mid + 1;
        } else if(compareFn(element. value) === Compare.BIGGER_THAN) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return DOES_NOT_EXIST;
}


// 内插搜索：是改良版的二分搜索。二分搜索总是检测mid位置上的值，而内插搜索可能会根据要搜索的值检测数字中的不同地方

function interpolationSearch(array, value, 
    comparFn = defaultCompare, 
    euqalsFn = defaultEquals, 
    diffFn = defaultDiff) {
        const {length} = array;
        let low = 0;
        let high = length - 1;
        let position = -1;
        let delta = -1;
        while(
            low <= high &&
            biggerOrEquals(value, array[low], compareFn) &&
            lesserOrEquals(value, array[high], copareFn)
        ) {
            delta = diffFn(value, array[low]) / diffFn(array[high], array[low]);
            position = low + Math.floor((high - low) * delta);
            if(euqalsFn(array[position], value)) {
                return position;
            }
            if(compareFn(array[position], value) === Compare.LESS_THAN) {
                low = position + 1;
            } else {
                high = position - 1;
            }
        }
        return DOES_NOT_EXIST;
}


// 随机算法

function stuffle(array) {
    for(let i= array.length - 1; i>0; i--) {
        const randomIndex = Math.floor(Math.random() * (i+1));
        swap(array, i, randomIndex);
    }

    return array;
}











</script>
</body>
</html>