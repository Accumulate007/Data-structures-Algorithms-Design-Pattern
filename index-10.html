<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>图</title>
</head>
<body>




<script>
/**
 * 图：是由一组由边连接的节点。
 *一个图 G = (V, E)
 *V：一组顶点
 *E：一组边，连接V中的顶点
 *
 *由一条边连接在一起的顶点称为相邻顶点，一个顶点的度，是其相邻顶点的数量。
 *路径是顶点的一个连续
 *图可以是无向或者有向的，有向图的边有一个方向。
 *如果图中两个顶点间在双向上都存在路径，则该图是强连通的。
 * 
 *
*/

// 创建Graph类

class Graph {
    constructor(isDirected = false) {
        this.isDirected = isDirected;
        this.vertices = [];
        this.adjList = new Dictionary();
    }

    // 参数v为顶点
    addVertex(v) {
        if(!this.vertices.includes(v)) {
            this.vertices.push(v);
            this.adjList.sev(v, []);
        }
    }

    // 将两个顶点v,w建立连接
    addEdge(v, w) {
        if(!this.adjList.get(v)) {
            this.addVertex(v);
        }
        if(!this.adjList.get(w)) {
            this.addVertex(w);
        }
        this.adjList.get(v).push(w);
        if(!this.isDirected) {
            this.adjList.get(w).push(v);
        }
    }

    getVertices() {
        return this.vertices;
    }

    getAdjList() {
        return this.adjList;
    }
}


/**
有两种方法可以对图进行遍历
1.广度优先搜索(breadth-first search)
2.深度优先搜索(depth-first search)

图遍历算法的思想是，必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。
对于两种图遍历算法，都需要明确指出第一个被访问的顶点。


*/


const Colors = {
    'WHITE': 0,     // 表示该顶点还没被访问过
    'GREY': 1,      // 表示该顶点被访问过，但未被探索过
    'BLACK': 2      // 表示该顶点被访问过，并且被完全探索过
}

const initializeColor = function (vertices) {
    const color = {};
    for(let i=0; i< vertices.length; i++) {
        color[vertices[i]] = Colors.WHITE;
    }
    return color;
}


// 广度优先算法
// 广度优先算法会从指定的第一个顶点开始遍历，先访问其所有的相邻节点(一次访问图的一层)。也就是先宽度，后深度地访问顶点。

const breadthFirstSearch = (graph, startVertex, callback) => {
    const vertices = graph.getVertices();
    const adjList = graph.getAdjList();
    const color = initializeColor(vertices);
    const queue = new Queue();  // 广度优先算法使用的是 队列 的数据结构

    queue.enqueue(startVertex);

    while(!queue.isEmpty()) {
        const u = queue.dequeue();
        const neighbors = adjList.get(u);
        color[u] = Colors.GREY;
        for(let i=0; i<neighbors.length; i++) {
            const w = neighbors[i];
            if(color[w] === Colors.WHITE) {
                color[w] = Colors.GREY;
                queue.enqueue(w);
            }
        }
        color[u] = Colors.BLACK;
        if(callback) {
            callback(u);
        }
    }
}


// 深度优先(使用栈的数据结构)
const depthFirstSearch = (graph, callback) => {
    const vertices = graph.getVertices();
    const adjList = graph.getAdjList();
    const color = initializeColor(verties);

    for(let i=0; i<vertices.length; i++) {
        if(color[vertices[i]] === Colors.WHITE) {
            depthFirstSearchVisit(vertices[i], color, adjList, callback);
        }
    }

    const depthFirstSearchVisit = (u, color, adjList, callback) => {
        color[u] = Colors.GREY;
        if(callback) {
            callback(u);
        }
    }

    const neighbors = adjList.get(u);
    for(let i=0; i<neighbors.length; i++) {
        const w = neighbors[i];
        if(color[w] === Colors.WHITE) {
            depthFirstSearchVisit(w, color, adjList, callback);
        }
    }
    color[u] = Colors.BLACK;
}






</script>
</body>
</html>