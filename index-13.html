<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>算法设计与技巧</title>
</head>
<body>




<script>
/**
 * 分而治之算法
 *动态规划
 *贪心算法
 * 回溯算法
 *
*/

const Compare = {
    'LESS_THAN': 'LESS_THAN',
    'BIGGER_THAN': 'BIGGER_THAN',
    'EQUALS': 'EQUALS'
}

const DOES_NOT_EXIST = -1;

// 分而治之。该算法可以分为三个部分
// 1.分解元问题为多个子问题
// 2.解决子问题，用返回解决子问题的方式的递归算法。
// 3.组合这些子问题的解决方式，从而得到原问题的解。


// 分而治之实现二分搜索
function binarySearchRecursive(array, value, low, high, compareFn = defaultCompare) {
    if(low <= hight) {
        const mid = Math.floor((low + higth) / 2);
        const element = array[mid];

        if(compareFn(element, value) === Compare.LESS.THAN) {
            return binarySearchRecursive(array, value, mid + 1, high, compareFn);
        } else if(compareFn(element, value) === Compare.BIGGER_THAN) {
            return binarySearchRecursive(array, value, low, mid-1, compareFn);
        } else {
            return mid;
        }
    }
    return DOES_NOT_EXIST;
}

function binarySearch(array, value, compareFn = defaultCompare) {
    const sortedArray = quickSort(array);
    const low = 0;
    const high = sortedArray.length - 1;

    return binarySearchRecursive(array, value, low, high, compareFn);
}


// 动态规划：是一种将复杂问题分解成更小的子问题来解决的优化技术。
// 分而治之是将问题分解成相互独立的子问题，然后组合它们的答案；而动态规划是将问题分解成互相依赖的子问题。
// 动态规划的三个步骤：1.定义子问题；2.实现要反复执行来解决子问题的部分；3.识别并求解出基线条件。


// 动态规划之 最少硬币找零问题
function minCoinChange(coins, amount) {
    // coins 是货币面值的集合，例如中国的货币面值有 [0.5,1,5,10,50,100]
    // amount 是需要找零的数额
    const cache = [];
    const makeChange = (value) => {
        if(!value) {
            return [];
        }
        if(cache[value]) {
            return cache[value];
        }
        let min = [];
        let newMin;
        let newAmount;
        for(let i=0; i<coins.length; i++) {
            const coin = conins[i];
            newAmount = value - coin;
            if(newAmount >= 0) {
                newMin = makeChange(newAmount);
            }
            if(
                newAmount >= 0 &&
                (newMin.length < min.length -1) || !min.length &&
                (newMin.length || !newAmount)
            ) {
                min = [coin].concat(newMin);
            }
        }
        return (cache[value] = min);
    }
    return makeChange(amount);
}


// 动态规划之 背包问题：给定一个固定大小、能够携重量W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入
// 背包的物品总重量不超过W，且总价值最大
function knapSack(capacity, weights, values, n) {
    const kS = [];
    for(let i=0; i<=n; i++) {
        kS[i] = [];
    }

    for(let i=0; i <= n; i++) {
        for(let w=0; w<=capacity; w++) {
            if(i === 0 || w === 0) {
                kS[i][w] = 0;
            } else if(weights[i-1] <= w) {
                const a = values[i-1] + kS[i-1][w-weights[i - 1]];
                const b = kS[i - 1][w];
                kS[i][w] = a > b ? a : b;
            } else {
                kS[i][w] = kS[i -1][w];
            }
        }
    }

    findValues(n, capacity, kS, weights, values);
    return kS[n][capacity];
}

function findValues(n, capacity, kS, weights, values) {
    let i = n;
    let k = capacity;
    while(i > 0 && k > 0) {
        if(kS[i][k] !== kS[i-1][k]) {
            i--;
            k -= kS[i][k];
        } else {
            i--;
        }
    }
}


// 动态规划之 最长公共子序列：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，
// 但不要求连续的字符串序列。

function lcs(wordX, wordY) {
    const m = wordX.length;
    const n = wordY.length;
    const l = [];

    for(let i=0; i <= m; i++) {
        l[i] = [];
        for(let j=0; j <= n; j++) {
            l[i][j] = 0;
        }
    }

    for(let i=0; i <= m; i++) {
        for(let j=0; j <= n; j++) {
            if(i === 0 || j === 0) {
                l[i][j] = 0;
            } else if(wordX[i - 1] === wordY[j - 1]) {
                l[i][j] = l[i -1][j - 1] + 1;
            } else {
                const a = l[i -1][j];
                const b = l[i][j -1];
                l[i][j] = a > b ? a : b;
            }
        }
    }
    return l[m][n];
}


// 动态规划之 矩阵链相乘：找出一组矩阵相乘的最佳方式(顺序)
function matrixChainOrder(p) {
    const n = p.length;
    const m = [];
    const s = [];
    for(let i=1; i <= n; i++) {
        m[i] = [];
        m[i][i] = 0;
    }

    for(let l = 2; l < n; l++) {
        for(let i=1; i <= (n-1) + 1; i++) {
            const j = (i + 1) - 1;
            m[i][j] = Number.MAX_SAFE_INTERGER;
            for(let k=i; k <= j - 1; k++) {
                const q = m[i][k] + m[k+1][j] + ((p[i-1] * p[k]) * p[j]);
                if(q < m[i][j]) {
                    m[i][j] = q;
                }
            }
        }
    }
    return m[1][n-1];
}




</script>
</body>
</html>